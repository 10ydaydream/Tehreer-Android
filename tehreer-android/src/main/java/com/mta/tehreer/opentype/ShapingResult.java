/*
 * Copyright (C) 2017 Muhammad Tayyab Akram
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.mta.tehreer.opentype;

import com.mta.tehreer.internal.Constants;
import com.mta.tehreer.internal.JNILoader;
import com.mta.tehreer.internal.collection.RawInt32Floats;
import com.mta.tehreer.internal.collection.RawInt32Points;
import com.mta.tehreer.internal.collection.RawSizeValues;
import com.mta.tehreer.internal.collection.RawUInt16Values;
import com.mta.tehreer.util.Disposable;
import com.mta.tehreer.util.FloatList;
import com.mta.tehreer.util.IntList;
import com.mta.tehreer.util.PointList;

/**
 * A <code>ShapingResult</code> object is a container for the results of OpenType text shaping. It
 * is generated by a <code>ShapingEngine</code> object to provide the information related to
 * characters, their glyphs, offsets, and advances.
 */
public class ShapingResult implements Disposable {

    static {
        JNILoader.load();
    }

    private static class Finalizable extends ShapingResult {

        private Finalizable(ShapingResult parent) {
            super(parent);
        }

        @Override
        public void dispose() {
            throw new UnsupportedOperationException(Constants.EXCEPTION_FINALIZABLE_OBJECT);
        }

        @Override
        protected void finalize() throws Throwable {
            try {
                super.dispose();
            } finally {
                super.finalize();
            }
        }
    }

    /**
     * Wraps a shaping result object into a finalizable instance which is guaranteed to be
     * disposed automatically by the GC when no longer in use. After calling this method,
     * <code>dispose()</code> should not be called on either original object or returned object.
     * Calling <code>dispose()</code> on returned object will throw an
     * <code>UnsupportedOperationException</code>.
     * <p>
     * <strong>Note:</strong> The behavior is undefined if the passed-in object is already disposed
     * or wrapped into another finalizable instance.
     *
     * @param shapingResult The shaping result object to wrap into a finalizable instance.
     * @return The finalizable instance of the passed-in shaping result object.
     */
    public static ShapingResult finalizable(ShapingResult shapingResult) {
        if (shapingResult.getClass() == ShapingResult.class) {
            return new Finalizable(shapingResult);
        }

        if (shapingResult.getClass() != Finalizable.class) {
            throw new IllegalArgumentException(Constants.EXCEPTION_SUBCLASS_NOT_SUPPORTED);
        }

        return shapingResult;
    }

    /**
     * Checks whether a shaping result object is finalizable or not.
     *
     * @param shapingResult The shaping result object to check.
     * @return <code>true</code> if the passed-in shaping result object is finalizable,
     *         <code>false</code> otherwise.
     */
    public static boolean isFinalizable(ShapingResult shapingResult) {
        return (shapingResult.getClass() == Finalizable.class);
    }

	long nativeResult;

    /**
     * Constructs a shaping result object.
     */
	ShapingResult() {
	    nativeResult = nativeCreate();
	}

    private ShapingResult(ShapingResult other) {
        this.nativeResult = other.nativeResult;
    }

    /**
     * Returns <code>true</code> if the text flows backward for this <code>ShapingResult</code>
     * object.
     *
     * @return <code>true</code> if the text flows backward, <code>false</code> otherwise.
     */
	public boolean isBackward() {
	    return nativeIsBackward(nativeResult);
	}

    /**
     * Returns the index to the first character in source text for this <code>ShapingResult</code>
     * object.
     *
     * @return The index to the first character in source text.
     */
	public int getCharStart() {
        return nativeGetCharStart(nativeResult);
    }

    /**
     * Returns the index after the last character in source text for this <code>ShapingResult</code>
     * object.
     *
     * @return The index after the last character in source text.
     */
    public int getCharEnd() {
        return nativeGetCharEnd(nativeResult);
    }

    /**
     * Returns the number of glyphs in this <code>ShapingResult</code> object.
     *
     * @return The number of glyphs in this <code>ShapingResult</code> object.
     */
	public int getGlyphCount() {
		return nativeGetGlyphCount(nativeResult);
	}

    /**
     * Returns a list of glyph IDs in this <code>ShapingResult</code> object.
     * <p>
     * <strong>Note:</strong> The returned list might exhibit undefined behavior if the
     * <code>ShapingResult</code> object is disposed.
     *
     * @return A list of glyph IDs.
     */
    public IntList getGlyphIds() {
        return new RawUInt16Values(nativeGetGlyphIdsPtr(nativeResult),
                                   nativeGetGlyphCount(nativeResult));
    }

    /**
     * Returns a list of glyph offsets in this <code>ShapingResult</code> object.
     * <p>
     * <strong>Note:</strong> The returned list might exhibit undefined behavior if the
     * <code>ShapingResult</code> object is disposed.
     *
     * @return A list of glyph offsets.
     */
    public PointList getGlyphOffsets() {
        return new RawInt32Points(nativeGetGlyphOffsetsPtr(nativeResult),
                                  nativeGetGlyphCount(nativeResult),
                                  nativeGetSizeByEm(nativeResult));
    }

    /**
     * Returns a list of glyph advances in this <code>ShapingResult</code> object.
     * <p>
     * <strong>Note:</strong> The returned list might exhibit undefined behavior if the
     * <code>ShapingResult</code> object is disposed.
     *
     * @return A list of glyph advances.
     */
    public FloatList getGlyphAdvances() {
        return new RawInt32Floats(nativeGetGlyphAdvancesPtr(nativeResult),
                                  nativeGetGlyphCount(nativeResult),
                                  nativeGetSizeByEm(nativeResult));
    }

    /**
     * Returns a list of indexes, mapping each shaped character in source string to corresponding
     * glyph. The list will be empty if no glyph is produced.
     * <p>
     * The map is produced according to following rules.
     * <ul>
     *      <li>If a single character translates into multiple glyphs, then it maps to the first
     *          glyph in the sequence.</li>
     *      <li>If multiple characters combine to make a single code point which in turn translates
     *          into multiple glyphs, then each character maps to the first glyph in the
     *          sequence.</li>
     *      <li>If multiple characters translate to a single glyph or ligature, then each
     *          participating character, whether consecutive or not, maps to this glyph or
     *          ligature.</li>
     * </ul>
     * <p>
     * <strong>Note:</strong> The returned list might exhibit undefined behavior if the
     * <code>ShapingResult</code> object is disposed.
     *
     * @return A list of indexes, mapping each shaped character in source string to corresponding
     *         glyph.
     */
    public IntList getClusterMap() {
        long pointer = nativeGetClusterMapPtr(nativeResult);
        int size = (pointer != 0 ? nativeGetCharCount(nativeResult) : 0);
        return new RawSizeValues(pointer, size);
    }

	@Override
	public void dispose() {
        nativeDispose(nativeResult);
    }

    @Override
    public String toString() {
        return "ShapingResult{isBackward=" + Boolean.toString(isBackward())
                + ", charStart=" + getCharStart()
                + ", charEnd=" + getCharEnd()
                + ", glyphCount=" + getGlyphCount()
                + ", glyphIds=" + getGlyphIds().toString()
                + ", glyphOffsets=" + getGlyphOffsets().toString()
                + ", glyphAdvances=" + getGlyphAdvances().toString()
                + ", clusterMap=" + getClusterMap().toString()
                + "}";
    }

	private static native long nativeCreate();
	private static native void nativeDispose(long nativeResult);

	private static native boolean nativeIsBackward(long nativeResult);
    private static native float nativeGetSizeByEm(long nativeResult);
	private static native int nativeGetCharStart(long nativeResult);
	private static native int nativeGetCharEnd(long nativeResult);
    private static native int nativeGetCharCount(long nativeResult);
	private static native int nativeGetGlyphCount(long nativeResult);

    private static native long nativeGetGlyphIdsPtr(long nativeResult);
    private static native long nativeGetGlyphOffsetsPtr(long nativeResult);
    private static native long nativeGetGlyphAdvancesPtr(long nativeResult);
    private static native long nativeGetClusterMapPtr(long nativeResult);
}
